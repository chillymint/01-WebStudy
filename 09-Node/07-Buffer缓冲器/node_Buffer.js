/*
 * 1.Buffer是什么？
 *    1.它是一个【类似于数组】的对象，用于存储数据（存储的是二进制数据）。
 *    2.Buffer的效率很高，存储和读取很快，它是直接对计算机的内存进行操作。
 *    3.Buffer的大小一旦确定了，不可修改。
 *    4.每个元素占用内存的大小为1字节。
 *    5.Buffer是Node中的非常核心的模块，无需下载、无需引入,直接即可使用
 *
 * 2. 进制转化
 *       十六进制：00 ----- ff
 *       十进制：0 ----- 255
 *       二进制：00000000 ------ 11111111
 *
 * 3.内存单位的换算
 *       8位(bit)  = 1字节(Byte)
 *       1024Byte = 1KB
 *       1024Kb = 1MB
 *       1024Mb = 1GB
 *       ...
 * */

//1.使用new关键字创建一个Buffer实例，即将废弃，效率低性能差(做了两件事：1.在堆内开辟空间 2.清理空间，去除垃圾对象)
let buf = new Buffer(10) // 括号内放的是地址长度
console.log(buf)

//2.使用Buffer.alloc创建一个Buffer实例，效率比new关键字稍高(只做一件事：在堆内开辟一块没有被使用过的空间)
let buf2 = Buffer.alloc(10) // 括号内放的是地址长度
console.log(buf2)

//3.Buffer.allocUnsafe创建一个Buffer实例，效率最高的一种方式(只做一件事：在堆内开辟空间，不安全，因为如果开辟了之前被使用的空间就可能会带有之前的信息)
/*
 * 1.为什么通过Buffer.allocUnsafe创建出来的实例，里面不为空？
 *     如果开辟了之前被使用的空间就可能会带有之前的信息
 * 2.为什么存的是二进制，输出的却不是二进制？
 *     存储的确实为二进制数据，但是，一旦输出为了便于观察，自动转成16进制。
 * */
let buf3 = Buffer.allocUnsafe(10) // 括号内放的是地址长度
console.log(buf3)

//4.将一个字符串保存在Buffer中
/*
 *       1.为什么输出的不是存入的字符串？
 *          输出的是十六进制
 *       2.如何显示输入的内容？
 *          toString()，但用户存入的也可能是媒体类型的文件
 */
let str = 'Hello World'
let buf4 = Buffer.from(str)
console.log(buf4)
console.log(buf4.toString())
